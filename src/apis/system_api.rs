/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.6.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `delete_sys_audit_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysAuditPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_auth_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysAuthPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_config_auditing_request_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysConfigAuditingRequestHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_config_cors`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysConfigCorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_config_ui_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysConfigUiHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_generate_root`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysGenerateRootError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_generate_root_attempt`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysGenerateRootAttemptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_mounts_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysMountsPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_plugins_catalog_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysPluginsCatalogNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_plugins_catalog_type_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysPluginsCatalogTypeNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_policies_acl_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysPoliciesAclNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_policies_password_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysPoliciesPasswordNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_policy_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysPolicyNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_quotas_rate_limit_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysQuotasRateLimitNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_raw`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRawError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_raw_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRawPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_rekey_backup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRekeyBackupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_rekey_init`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRekeyInitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_rekey_recovery_key_backup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRekeyRecoveryKeyBackupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sys_rekey_verify`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSysRekeyVerifyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_audit`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysAuditError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_auth`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysAuthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_auth_path_tune`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysAuthPathTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_auditing_request_headers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigAuditingRequestHeadersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_auditing_request_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigAuditingRequestHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_cors`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigCorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_state_sanitized`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigStateSanitizedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_ui_headers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigUiHeadersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_config_ui_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysConfigUiHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_generate_root`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysGenerateRootError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_generate_root_attempt`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysGenerateRootAttemptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_health`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysHealthError {
    Status429(),
    Status472(),
    Status501(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_host_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysHostInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_init`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_internal_counters_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInternalCountersActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_internal_counters_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInternalCountersConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_internal_specs_openapi`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInternalSpecsOpenapiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_internal_ui_mounts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInternalUiMountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_internal_ui_mounts_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysInternalUiMountsPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_key_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysKeyStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_leader`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysLeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_leases_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysLeasesLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_leases_lookup_prefix`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysLeasesLookupPrefixError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_metrics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysMetricsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_monitor`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysMonitorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_mounts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysMountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_mounts_path_tune`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysMountsPathTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_plugins_catalog`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPluginsCatalogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_plugins_catalog_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPluginsCatalogNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_plugins_catalog_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPluginsCatalogTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_plugins_catalog_type_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPluginsCatalogTypeNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policies_acl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPoliciesAclError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policies_acl_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPoliciesAclNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policies_password_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPoliciesPasswordNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policies_password_name_generate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPoliciesPasswordNameGenerateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_policy_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPolicyNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_cmdline`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofCmdlineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_goroutine`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofGoroutineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_heap`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofHeapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_profile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_symbol`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofSymbolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_pprof_trace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysPprofTraceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_quotas_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysQuotasConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_quotas_rate_limit`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysQuotasRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_quotas_rate_limit_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysQuotasRateLimitNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_raw`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRawError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_raw_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRawPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_rekey_backup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRekeyBackupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_rekey_init`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRekeyInitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_rekey_recovery_key_backup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRekeyRecoveryKeyBackupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_rekey_verify`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysRekeyVerifyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_replication_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysReplicationStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_seal_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysSealStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_sys_wrapping_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSysWrappingLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_audit_hash_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysAuditHashPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_audit_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysAuditPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_auth_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysAuthPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_auth_path_tune`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysAuthPathTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_capabilities`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysCapabilitiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_capabilities_accessor`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysCapabilitiesAccessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_capabilities_self`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysCapabilitiesSelfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_config_auditing_request_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysConfigAuditingRequestHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_config_cors`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysConfigCorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_config_ui_headers_header`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysConfigUiHeadersHeaderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_generate_root`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysGenerateRootError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_generate_root_attempt`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysGenerateRootAttemptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_generate_root_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysGenerateRootUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_init`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysInitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_internal_counters_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysInternalCountersConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_renew`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRenewError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_renew_url_lease_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRenewUrlLeaseIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_revoke`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRevokeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_revoke_force_prefix`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRevokeForcePrefixError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_revoke_prefix_prefix`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRevokePrefixPrefixError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_revoke_url_lease_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesRevokeUrlLeaseIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_leases_tidy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysLeasesTidyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_mounts_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysMountsPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_mounts_path_tune`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysMountsPathTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_plugins_catalog_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPluginsCatalogNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_plugins_catalog_type_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPluginsCatalogTypeNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_plugins_reload_backend`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPluginsReloadBackendError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_policies_acl_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPoliciesAclNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_policies_password_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPoliciesPasswordNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_policy_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysPolicyNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_quotas_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysQuotasConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_quotas_rate_limit_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysQuotasRateLimitNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_raw`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRawError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_raw_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRawPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_rekey_init`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRekeyInitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_rekey_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRekeyUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_rekey_verify`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRekeyVerifyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_remount`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRemountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_renew`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRenewError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_renew_url_lease_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRenewUrlLeaseIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_revoke`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRevokeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_revoke_force_prefix`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRevokeForcePrefixError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_revoke_prefix_prefix`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRevokePrefixPrefixError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_revoke_url_lease_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRevokeUrlLeaseIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_rotate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysRotateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_seal`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysSealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_step_down`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysStepDownError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_tools_hash`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysToolsHashError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_tools_hash_urlalgorithm`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysToolsHashUrlalgorithmError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_tools_random`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysToolsRandomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_tools_random_urlbytes`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysToolsRandomUrlbytesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_unseal`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysUnsealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_wrapping_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysWrappingLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_wrapping_rewrap`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysWrappingRewrapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_wrapping_unwrap`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysWrappingUnwrapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_sys_wrapping_wrap`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSysWrappingWrapError {
    UnknownValue(serde_json::Value),
}


pub async fn delete_sys_audit_path(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<DeleteSysAuditPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/audit/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysAuditPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_auth_path(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<DeleteSysAuthPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/auth/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysAuthPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_config_auditing_request_headers_header(configuration: &configuration::Configuration, header: &str) -> Result<(), Error<DeleteSysConfigAuditingRequestHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/auditing/request-headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysConfigAuditingRequestHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_config_cors(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysConfigCorsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/cors", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysConfigCorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_config_ui_headers_header(configuration: &configuration::Configuration, header: &str) -> Result<(), Error<DeleteSysConfigUiHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/ui/headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysConfigUiHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_generate_root(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysGenerateRootError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysGenerateRootError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_generate_root_attempt(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysGenerateRootAttemptError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root/attempt", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysGenerateRootAttemptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_mounts_path(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<DeleteSysMountsPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/mounts/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysMountsPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_plugins_catalog_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteSysPluginsCatalogNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysPluginsCatalogNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_plugins_catalog_type_name(configuration: &configuration::Configuration, name: &str, _type: &str) -> Result<(), Error<DeleteSysPluginsCatalogTypeNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{type}/{name}", configuration.base_path, name=crate::apis::urlencode(name), type=crate::apis::urlencode(_type));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysPluginsCatalogTypeNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_policies_acl_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteSysPoliciesAclNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/acl/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysPoliciesAclNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_policies_password_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteSysPoliciesPasswordNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/password/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysPoliciesPasswordNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_policy_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteSysPolicyNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policy/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysPolicyNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_quotas_rate_limit_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteSysQuotasRateLimitNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/rate-limit/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysQuotasRateLimitNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_raw(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysRawError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_raw_path(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<DeleteSysRawPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRawPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_rekey_backup(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysRekeyBackupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/backup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRekeyBackupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
pub async fn delete_sys_rekey_init(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysRekeyInitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/init", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRekeyInitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sys_rekey_recovery_key_backup(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysRekeyRecoveryKeyBackupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/recovery-key-backup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRekeyRecoveryKeyBackupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
pub async fn delete_sys_rekey_verify(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteSysRekeyVerifyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/verify", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSysRekeyVerifyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_audit(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysAuditError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/audit", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysAuditError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_auth(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysAuthError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/auth", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysAuthError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
pub async fn get_sys_auth_path_tune(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<GetSysAuthPathTuneError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/auth/{path}/tune", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysAuthPathTuneError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_config_auditing_request_headers(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysConfigAuditingRequestHeadersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/auditing/request-headers", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigAuditingRequestHeadersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_config_auditing_request_headers_header(configuration: &configuration::Configuration, header: &str) -> Result<(), Error<GetSysConfigAuditingRequestHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/auditing/request-headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigAuditingRequestHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_config_cors(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysConfigCorsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/cors", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigCorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
pub async fn get_sys_config_state_sanitized(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysConfigStateSanitizedError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/state/sanitized", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigStateSanitizedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_config_ui_headers(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysConfigUiHeadersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/ui/headers/", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigUiHeadersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_config_ui_headers_header(configuration: &configuration::Configuration, header: &str) -> Result<(), Error<GetSysConfigUiHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/ui/headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysConfigUiHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_generate_root(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysGenerateRootError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysGenerateRootError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_generate_root_attempt(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysGenerateRootAttemptError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root/attempt", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysGenerateRootAttemptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_health(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysHealthError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/health", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysHealthError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
pub async fn get_sys_host_info(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysHostInfoError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/host-info", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysHostInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_init(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysInitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/init", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_internal_counters_activity(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysInternalCountersActivityError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/counters/activity", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInternalCountersActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_internal_counters_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysInternalCountersConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/counters/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInternalCountersConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_internal_specs_openapi(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysInternalSpecsOpenapiError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/specs/openapi", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInternalSpecsOpenapiError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_internal_ui_mounts(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysInternalUiMountsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/ui/mounts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInternalUiMountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_internal_ui_mounts_path(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<GetSysInternalUiMountsPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/ui/mounts/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysInternalUiMountsPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_key_status(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysKeyStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/key-status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysKeyStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_leader(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysLeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leader", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysLeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_leases_lookup(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysLeasesLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/lookup/", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysLeasesLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_leases_lookup_prefix(configuration: &configuration::Configuration, prefix: &str, list: Option<&str>) -> Result<(), Error<GetSysLeasesLookupPrefixError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/lookup/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysLeasesLookupPrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_metrics(configuration: &configuration::Configuration, format: Option<&str>) -> Result<(), Error<GetSysMetricsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/metrics", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = format {
        local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysMetricsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_monitor(configuration: &configuration::Configuration, log_level: Option<&str>) -> Result<(), Error<GetSysMonitorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/monitor", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = log_level {
        local_var_req_builder = local_var_req_builder.query(&[("log_level", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysMonitorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_mounts(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysMountsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/mounts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysMountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_mounts_path_tune(configuration: &configuration::Configuration, path: &str) -> Result<(), Error<GetSysMountsPathTuneError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/mounts/{path}/tune", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysMountsPathTuneError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_plugins_catalog(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPluginsCatalogError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPluginsCatalogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_plugins_catalog_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysPluginsCatalogNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPluginsCatalogNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_plugins_catalog_type(configuration: &configuration::Configuration, _type: &str, list: Option<&str>) -> Result<(), Error<GetSysPluginsCatalogTypeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{type}", configuration.base_path, type=crate::apis::urlencode(_type));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPluginsCatalogTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_plugins_catalog_type_name(configuration: &configuration::Configuration, name: &str, _type: &str) -> Result<(), Error<GetSysPluginsCatalogTypeNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{type}/{name}", configuration.base_path, name=crate::apis::urlencode(name), type=crate::apis::urlencode(_type));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPluginsCatalogTypeNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policies_acl(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysPoliciesAclError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/acl", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPoliciesAclError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policies_acl_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysPoliciesAclNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/acl/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPoliciesAclNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policies_password_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysPoliciesPasswordNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/password/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPoliciesPasswordNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policies_password_name_generate(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysPoliciesPasswordNameGenerateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/password/{name}/generate", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPoliciesPasswordNameGenerateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policy(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysPolicyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policy", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_policy_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysPolicyNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policy/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPolicyNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
pub async fn get_sys_pprof(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the running program's command line, with arguments separated by NUL bytes.
pub async fn get_sys_pprof_cmdline(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofCmdlineError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/cmdline", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofCmdlineError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns stack traces of all current goroutines.
pub async fn get_sys_pprof_goroutine(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofGoroutineError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/goroutine", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofGoroutineError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a sampling of memory allocations of live object.
pub async fn get_sys_pprof_heap(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofHeapError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/heap", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofHeapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
pub async fn get_sys_pprof_profile(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofProfileError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/profile", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofProfileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the program counters listed in the request.
pub async fn get_sys_pprof_symbol(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofSymbolError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/symbol", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofSymbolError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
pub async fn get_sys_pprof_trace(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysPprofTraceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/pprof/trace", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysPprofTraceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_quotas_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysQuotasConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysQuotasConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_quotas_rate_limit(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysQuotasRateLimitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/rate-limit", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysQuotasRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_quotas_rate_limit_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetSysQuotasRateLimitNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/rate-limit/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysQuotasRateLimitNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_raw(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetSysRawError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_raw_path(configuration: &configuration::Configuration, path: &str, list: Option<&str>) -> Result<(), Error<GetSysRawPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRawPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_rekey_backup(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysRekeyBackupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/backup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRekeyBackupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_rekey_init(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysRekeyInitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/init", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRekeyInitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_rekey_recovery_key_backup(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysRekeyRecoveryKeyBackupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/recovery-key-backup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRekeyRecoveryKeyBackupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_rekey_verify(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysRekeyVerifyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/verify", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysRekeyVerifyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_replication_status(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysReplicationStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/replication/status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysReplicationStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_seal_status(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysSealStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/seal-status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysSealStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_sys_wrapping_lookup(configuration: &configuration::Configuration, ) -> Result<(), Error<GetSysWrappingLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/wrapping/lookup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetSysWrappingLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_audit_hash_path(configuration: &configuration::Configuration, path: &str, inline_object193: Option<crate::models::InlineObject193>) -> Result<(), Error<PostSysAuditHashPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/audit-hash/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object193);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysAuditHashPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_audit_path(configuration: &configuration::Configuration, path: &str, inline_object194: Option<crate::models::InlineObject194>) -> Result<(), Error<PostSysAuditPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/audit/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object194);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysAuditPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \"foo\" auth method will make it accessible at /auth/foo.
pub async fn post_sys_auth_path(configuration: &configuration::Configuration, path: &str, inline_object195: Option<crate::models::InlineObject195>) -> Result<(), Error<PostSysAuthPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/auth/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object195);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysAuthPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
pub async fn post_sys_auth_path_tune(configuration: &configuration::Configuration, path: &str, inline_object196: Option<crate::models::InlineObject196>) -> Result<(), Error<PostSysAuthPathTuneError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/auth/{path}/tune", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object196);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysAuthPathTuneError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_capabilities(configuration: &configuration::Configuration, inline_object197: Option<crate::models::InlineObject197>) -> Result<(), Error<PostSysCapabilitiesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/capabilities", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object197);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysCapabilitiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_capabilities_accessor(configuration: &configuration::Configuration, inline_object198: Option<crate::models::InlineObject198>) -> Result<(), Error<PostSysCapabilitiesAccessorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/capabilities-accessor", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object198);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysCapabilitiesAccessorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_capabilities_self(configuration: &configuration::Configuration, inline_object199: Option<crate::models::InlineObject199>) -> Result<(), Error<PostSysCapabilitiesSelfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/capabilities-self", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object199);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysCapabilitiesSelfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_config_auditing_request_headers_header(configuration: &configuration::Configuration, header: &str, inline_object200: Option<crate::models::InlineObject200>) -> Result<(), Error<PostSysConfigAuditingRequestHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/auditing/request-headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object200);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysConfigAuditingRequestHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_config_cors(configuration: &configuration::Configuration, inline_object201: Option<crate::models::InlineObject201>) -> Result<(), Error<PostSysConfigCorsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/cors", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object201);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysConfigCorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_config_ui_headers_header(configuration: &configuration::Configuration, header: &str, inline_object202: Option<crate::models::InlineObject202>) -> Result<(), Error<PostSysConfigUiHeadersHeaderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/config/ui/headers/{header}", configuration.base_path, header=crate::apis::urlencode(header));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object202);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysConfigUiHeadersHeaderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
pub async fn post_sys_generate_root(configuration: &configuration::Configuration, inline_object203: Option<crate::models::InlineObject203>) -> Result<(), Error<PostSysGenerateRootError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object203);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysGenerateRootError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
pub async fn post_sys_generate_root_attempt(configuration: &configuration::Configuration, inline_object204: Option<crate::models::InlineObject204>) -> Result<(), Error<PostSysGenerateRootAttemptError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root/attempt", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object204);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysGenerateRootAttemptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the threshold number of master key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
pub async fn post_sys_generate_root_update(configuration: &configuration::Configuration, inline_object205: Option<crate::models::InlineObject205>) -> Result<(), Error<PostSysGenerateRootUpdateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/generate-root/update", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object205);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysGenerateRootUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
pub async fn post_sys_init(configuration: &configuration::Configuration, inline_object206: Option<crate::models::InlineObject206>) -> Result<(), Error<PostSysInitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/init", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object206);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysInitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_internal_counters_config(configuration: &configuration::Configuration, inline_object207: Option<crate::models::InlineObject207>) -> Result<(), Error<PostSysInternalCountersConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/internal/counters/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object207);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysInternalCountersConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_lookup(configuration: &configuration::Configuration, inline_object208: Option<crate::models::InlineObject208>) -> Result<(), Error<PostSysLeasesLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/lookup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object208);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_renew(configuration: &configuration::Configuration, inline_object209: Option<crate::models::InlineObject209>) -> Result<(), Error<PostSysLeasesRenewError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/renew", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object209);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRenewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_renew_url_lease_id(configuration: &configuration::Configuration, url_lease_id: &str, inline_object210: Option<crate::models::InlineObject210>) -> Result<(), Error<PostSysLeasesRenewUrlLeaseIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/renew/{url_lease_id}", configuration.base_path, url_lease_id=crate::apis::urlencode(url_lease_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object210);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRenewUrlLeaseIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_revoke(configuration: &configuration::Configuration, inline_object211: Option<crate::models::InlineObject211>) -> Result<(), Error<PostSysLeasesRevokeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/revoke", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object211);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRevokeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
pub async fn post_sys_leases_revoke_force_prefix(configuration: &configuration::Configuration, prefix: &str) -> Result<(), Error<PostSysLeasesRevokeForcePrefixError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/revoke-force/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRevokeForcePrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_revoke_prefix_prefix(configuration: &configuration::Configuration, prefix: &str, inline_object212: Option<crate::models::InlineObject212>) -> Result<(), Error<PostSysLeasesRevokePrefixPrefixError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/revoke-prefix/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object212);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRevokePrefixPrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_revoke_url_lease_id(configuration: &configuration::Configuration, url_lease_id: &str, inline_object213: Option<crate::models::InlineObject213>) -> Result<(), Error<PostSysLeasesRevokeUrlLeaseIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/revoke/{url_lease_id}", configuration.base_path, url_lease_id=crate::apis::urlencode(url_lease_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object213);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesRevokeUrlLeaseIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_leases_tidy(configuration: &configuration::Configuration, ) -> Result<(), Error<PostSysLeasesTidyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/leases/tidy", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysLeasesTidyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_mounts_path(configuration: &configuration::Configuration, path: &str, inline_object214: Option<crate::models::InlineObject214>) -> Result<(), Error<PostSysMountsPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/mounts/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object214);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysMountsPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_mounts_path_tune(configuration: &configuration::Configuration, path: &str, inline_object215: Option<crate::models::InlineObject215>) -> Result<(), Error<PostSysMountsPathTuneError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/mounts/{path}/tune", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object215);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysMountsPathTuneError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_plugins_catalog_name(configuration: &configuration::Configuration, name: &str, inline_object216: Option<crate::models::InlineObject216>) -> Result<(), Error<PostSysPluginsCatalogNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object216);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPluginsCatalogNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_plugins_catalog_type_name(configuration: &configuration::Configuration, name: &str, _type: &str, inline_object217: Option<crate::models::InlineObject217>) -> Result<(), Error<PostSysPluginsCatalogTypeNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/catalog/{type}/{name}", configuration.base_path, name=crate::apis::urlencode(name), type=crate::apis::urlencode(_type));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object217);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPluginsCatalogTypeNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
pub async fn post_sys_plugins_reload_backend(configuration: &configuration::Configuration, inline_object218: Option<crate::models::InlineObject218>) -> Result<(), Error<PostSysPluginsReloadBackendError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/plugins/reload/backend", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object218);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPluginsReloadBackendError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_policies_acl_name(configuration: &configuration::Configuration, name: &str, inline_object219: Option<crate::models::InlineObject219>) -> Result<(), Error<PostSysPoliciesAclNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/acl/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object219);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPoliciesAclNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_policies_password_name(configuration: &configuration::Configuration, name: &str, inline_object220: Option<crate::models::InlineObject220>) -> Result<(), Error<PostSysPoliciesPasswordNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policies/password/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object220);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPoliciesPasswordNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_policy_name(configuration: &configuration::Configuration, name: &str, inline_object221: Option<crate::models::InlineObject221>) -> Result<(), Error<PostSysPolicyNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/policy/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object221);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysPolicyNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_quotas_config(configuration: &configuration::Configuration, inline_object222: Option<crate::models::InlineObject222>) -> Result<(), Error<PostSysQuotasConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object222);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysQuotasConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_quotas_rate_limit_name(configuration: &configuration::Configuration, name: &str, inline_object223: Option<crate::models::InlineObject223>) -> Result<(), Error<PostSysQuotasRateLimitNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/quotas/rate-limit/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object223);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysQuotasRateLimitNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_raw(configuration: &configuration::Configuration, inline_object224: Option<crate::models::InlineObject224>) -> Result<(), Error<PostSysRawError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object224);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_raw_path(configuration: &configuration::Configuration, path: &str, inline_object225: Option<crate::models::InlineObject225>) -> Result<(), Error<PostSysRawPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/raw/{path}", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object225);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRawPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
pub async fn post_sys_rekey_init(configuration: &configuration::Configuration, inline_object226: Option<crate::models::InlineObject226>) -> Result<(), Error<PostSysRekeyInitError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/init", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object226);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRekeyInitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_rekey_update(configuration: &configuration::Configuration, inline_object227: Option<crate::models::InlineObject227>) -> Result<(), Error<PostSysRekeyUpdateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/update", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object227);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRekeyUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_rekey_verify(configuration: &configuration::Configuration, inline_object228: Option<crate::models::InlineObject228>) -> Result<(), Error<PostSysRekeyVerifyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rekey/verify", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object228);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRekeyVerifyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_remount(configuration: &configuration::Configuration, inline_object229: Option<crate::models::InlineObject229>) -> Result<(), Error<PostSysRemountError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/remount", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object229);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRemountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_renew(configuration: &configuration::Configuration, inline_object230: Option<crate::models::InlineObject230>) -> Result<(), Error<PostSysRenewError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/renew", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object230);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRenewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_renew_url_lease_id(configuration: &configuration::Configuration, url_lease_id: &str, inline_object231: Option<crate::models::InlineObject231>) -> Result<(), Error<PostSysRenewUrlLeaseIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/renew/{url_lease_id}", configuration.base_path, url_lease_id=crate::apis::urlencode(url_lease_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object231);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRenewUrlLeaseIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_revoke(configuration: &configuration::Configuration, inline_object232: Option<crate::models::InlineObject232>) -> Result<(), Error<PostSysRevokeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/revoke", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object232);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRevokeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
pub async fn post_sys_revoke_force_prefix(configuration: &configuration::Configuration, prefix: &str) -> Result<(), Error<PostSysRevokeForcePrefixError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/revoke-force/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRevokeForcePrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_revoke_prefix_prefix(configuration: &configuration::Configuration, prefix: &str, inline_object233: Option<crate::models::InlineObject233>) -> Result<(), Error<PostSysRevokePrefixPrefixError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/revoke-prefix/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object233);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRevokePrefixPrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_revoke_url_lease_id(configuration: &configuration::Configuration, url_lease_id: &str, inline_object234: Option<crate::models::InlineObject234>) -> Result<(), Error<PostSysRevokeUrlLeaseIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/revoke/{url_lease_id}", configuration.base_path, url_lease_id=crate::apis::urlencode(url_lease_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object234);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRevokeUrlLeaseIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_rotate(configuration: &configuration::Configuration, ) -> Result<(), Error<PostSysRotateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/rotate", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysRotateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_seal(configuration: &configuration::Configuration, ) -> Result<(), Error<PostSysSealError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/seal", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysSealError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
pub async fn post_sys_step_down(configuration: &configuration::Configuration, ) -> Result<(), Error<PostSysStepDownError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/step-down", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysStepDownError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_tools_hash(configuration: &configuration::Configuration, inline_object235: Option<crate::models::InlineObject235>) -> Result<(), Error<PostSysToolsHashError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/tools/hash", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object235);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysToolsHashError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_tools_hash_urlalgorithm(configuration: &configuration::Configuration, urlalgorithm: &str, inline_object236: Option<crate::models::InlineObject236>) -> Result<(), Error<PostSysToolsHashUrlalgorithmError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/tools/hash/{urlalgorithm}", configuration.base_path, urlalgorithm=crate::apis::urlencode(urlalgorithm));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object236);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysToolsHashUrlalgorithmError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_tools_random(configuration: &configuration::Configuration, inline_object237: Option<crate::models::InlineObject237>) -> Result<(), Error<PostSysToolsRandomError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/tools/random", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object237);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysToolsRandomError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_tools_random_urlbytes(configuration: &configuration::Configuration, urlbytes: &str, inline_object238: Option<crate::models::InlineObject238>) -> Result<(), Error<PostSysToolsRandomUrlbytesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/tools/random/{urlbytes}", configuration.base_path, urlbytes=crate::apis::urlencode(urlbytes));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object238);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysToolsRandomUrlbytesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_unseal(configuration: &configuration::Configuration, inline_object239: Option<crate::models::InlineObject239>) -> Result<(), Error<PostSysUnsealError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/unseal", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object239);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysUnsealError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_wrapping_lookup(configuration: &configuration::Configuration, inline_object240: Option<crate::models::InlineObject240>) -> Result<(), Error<PostSysWrappingLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/wrapping/lookup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object240);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysWrappingLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_wrapping_rewrap(configuration: &configuration::Configuration, inline_object241: Option<crate::models::InlineObject241>) -> Result<(), Error<PostSysWrappingRewrapError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/wrapping/rewrap", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object241);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysWrappingRewrapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_wrapping_unwrap(configuration: &configuration::Configuration, inline_object242: Option<crate::models::InlineObject242>) -> Result<(), Error<PostSysWrappingUnwrapError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/wrapping/unwrap", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object242);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysWrappingUnwrapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_sys_wrapping_wrap(configuration: &configuration::Configuration, ) -> Result<(), Error<PostSysWrappingWrapError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/sys/wrapping/wrap", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostSysWrappingWrapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

