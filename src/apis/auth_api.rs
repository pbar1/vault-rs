/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.6.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `delete_auth_alicloud_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAlicloudRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_bind_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameBindSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_bound_cidr_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameBoundCidrListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_period`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNamePeriodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_policies`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNamePoliciesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_secret_id_accessor_destroy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_secret_id_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameSecretIdBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_secret_id_destroy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameSecretIdDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_secret_id_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameSecretIdNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_secret_id_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameSecretIdTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_token_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameTokenBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_token_max_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameTokenMaxTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_token_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameTokenNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_approle_role_role_name_token_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthApproleRoleRoleNameTokenTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_config_certificate_cert_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsConfigCertificateCertNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_config_client`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsConfigClientError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_config_sts_account_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsConfigStsAccountIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_config_tidy_identity_whitelist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsConfigTidyIdentityWhitelistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_config_tidy_roletag_blacklist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsConfigTidyRoletagBlacklistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_identity_whitelist_instance_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsIdentityWhitelistInstanceIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_aws_roletag_blacklist_role_tag`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAwsRoletagBlacklistRoleTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_azure_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAzureConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_azure_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthAzureRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_cert_certs_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthCertCertsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_cert_crls_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthCertCrlsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_gcp_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthGcpRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_github_map_teams_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthGithubMapTeamsKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_github_map_users_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthGithubMapUsersKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_jwt_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthJwtRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_kubernetes_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthKubernetesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_ldap_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthLdapGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_ldap_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthLdapUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_oidc_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthOidcRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_okta_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthOktaGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_okta_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthOktaUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_radius_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthRadiusUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_token_roles_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthTokenRolesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_auth_userpass_users_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAuthUserpassUsersUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_alicloud_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAlicloudRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_alicloud_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAlicloudRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_alicloud_roles`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAlicloudRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_bind_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameBindSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_bound_cidr_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameBoundCidrListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_local_secret_ids`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameLocalSecretIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_period`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNamePeriodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_policies`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNamePoliciesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_role_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameRoleIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_secret_id_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameSecretIdBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_secret_id_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameSecretIdNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_secret_id_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameSecretIdTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_token_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameTokenBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_token_max_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameTokenMaxTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_token_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameTokenNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_approle_role_role_name_token_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthApproleRoleRoleNameTokenTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_certificate_cert_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigCertificateCertNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_certificates`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigCertificatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_client`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigClientError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_identity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_sts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigStsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_sts_account_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigStsAccountIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_tidy_identity_whitelist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigTidyIdentityWhitelistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_config_tidy_roletag_blacklist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsConfigTidyRoletagBlacklistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_identity_whitelist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsIdentityWhitelistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_identity_whitelist_instance_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsIdentityWhitelistInstanceIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_roles`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_roletag_blacklist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsRoletagBlacklistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_aws_roletag_blacklist_role_tag`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAwsRoletagBlacklistRoleTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_azure_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAzureConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_azure_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAzureRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_azure_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthAzureRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_cert_certs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthCertCertsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_cert_certs_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthCertCertsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_cert_crls_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthCertCrlsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_gcp_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGcpConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_gcp_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGcpRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_gcp_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGcpRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_gcp_roles`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGcpRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_map_teams`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubMapTeamsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_map_teams_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubMapTeamsKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_map_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubMapUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_map_users_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubMapUsersKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_github_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthGithubMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_jwt_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthJwtConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_jwt_oidc_callback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthJwtOidcCallbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_jwt_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthJwtRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_jwt_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthJwtRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_kubernetes_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthKubernetesConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_kubernetes_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthKubernetesRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_kubernetes_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthKubernetesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_groups`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_ldap_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthLdapUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_oidc_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOidcConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_oidc_oidc_callback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOidcOidcCallbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_oidc_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOidcRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_oidc_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOidcRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_groups`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_okta_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthOktaUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_radius_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthRadiusConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_radius_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthRadiusDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_radius_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthRadiusMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_radius_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthRadiusUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_radius_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthRadiusUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_token_accessors`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthTokenAccessorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_token_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthTokenLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_token_lookup_self`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthTokenLookupSelfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_token_roles`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthTokenRolesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_token_roles_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthTokenRolesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_userpass_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthUserpassDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_userpass_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthUserpassMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_userpass_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthUserpassUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_auth_userpass_users_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthUserpassUsersUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_alicloud_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAlicloudLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_alicloud_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAlicloudRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_bind_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameBindSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_bound_cidr_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameBoundCidrListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_custom_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameCustomSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_period`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNamePeriodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_policies`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNamePoliciesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_role_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameRoleIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_accessor_destroy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdAccessorDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_accessor_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdAccessorLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_destroy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_secret_id_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameSecretIdTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_token_bound_cidrs`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameTokenBoundCidrsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_token_max_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameTokenMaxTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_token_num_uses`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameTokenNumUsesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_role_role_name_token_ttl`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleRoleRoleNameTokenTtlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_approle_tidy_secret_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthApproleTidySecretIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_certificate_cert_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigCertificateCertNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_client`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigClientError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_identity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigIdentityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_rotate_root`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigRotateRootError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_sts_account_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigStsAccountIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_tidy_identity_whitelist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigTidyIdentityWhitelistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_config_tidy_roletag_blacklist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsConfigTidyRoletagBlacklistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_role_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsRoleRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_role_role_tag`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsRoleRoleTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_roletag_blacklist_role_tag`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsRoletagBlacklistRoleTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_tidy_identity_whitelist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsTidyIdentityWhitelistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_aws_tidy_roletag_blacklist`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAwsTidyRoletagBlacklistError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_azure_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAzureConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_azure_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAzureLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_azure_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthAzureRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_cert_certs_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthCertCertsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_cert_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthCertConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_cert_crls_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthCertCrlsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_cert_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthCertLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_gcp_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGcpConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_gcp_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGcpLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_gcp_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGcpRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_gcp_role_name_labels`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGcpRoleNameLabelsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_gcp_role_name_service_accounts`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGcpRoleNameServiceAccountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_duo_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubDuoAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_map_teams_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubMapTeamsKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_map_users_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubMapUsersKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_github_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthGithubMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_jwt_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthJwtConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_jwt_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthJwtLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_jwt_oidc_auth_url`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthJwtOidcAuthUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_jwt_oidc_callback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthJwtOidcCallbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_jwt_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthJwtRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_kubernetes_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthKubernetesConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_kubernetes_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthKubernetesLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_kubernetes_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthKubernetesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_duo_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapDuoAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_login_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapLoginUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_ldap_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthLdapUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_oidc_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOidcConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_oidc_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOidcLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_oidc_oidc_auth_url`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOidcOidcAuthUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_oidc_oidc_callback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOidcOidcCallbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_oidc_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOidcRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_duo_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaDuoAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_groups_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaGroupsNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_login_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaLoginUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_okta_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthOktaUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_duo_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusDuoAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_login`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_login_urlusername`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusLoginUrlusernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_radius_users_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthRadiusUsersNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_create`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_create_orphan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenCreateOrphanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_create_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenCreateRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_lookup`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenLookupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_lookup_accessor`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenLookupAccessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_lookup_self`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenLookupSelfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_renew`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRenewError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_renew_accessor`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRenewAccessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_renew_self`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRenewSelfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_revoke`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRevokeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_revoke_accessor`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRevokeAccessorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_revoke_orphan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRevokeOrphanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_revoke_self`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRevokeSelfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_roles_role_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenRolesRoleNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_token_tidy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthTokenTidyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_duo_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassDuoAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_duo_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassDuoConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_login_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassLoginUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_mfa_config`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassMfaConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_users_username`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassUsersUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_users_username_password`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassUsersUsernamePasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_auth_userpass_users_username_policies`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthUserpassUsersUsernamePoliciesError {
    UnknownValue(serde_json::Value),
}


pub async fn delete_auth_alicloud_role_role(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<DeleteAuthAlicloudRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAlicloudRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_bind_secret_id(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameBindSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bind-secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameBindSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_bound_cidr_list(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameBoundCidrListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bound-cidr-list", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameBoundCidrListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_period(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNamePeriodError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/period", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNamePeriodError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_policies(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNamePoliciesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/policies", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNamePoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_secret_id_accessor_destroy(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-accessor/destroy", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_secret_id_bound_cidrs(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameSecretIdBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameSecretIdBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_secret_id_destroy(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameSecretIdDestroyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id/destroy", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameSecretIdDestroyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_secret_id_num_uses(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameSecretIdNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameSecretIdNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_secret_id_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameSecretIdTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameSecretIdTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_token_bound_cidrs(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameTokenBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameTokenBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_token_max_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameTokenMaxTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-max-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameTokenMaxTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_token_num_uses(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameTokenNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameTokenNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_approle_role_role_name_token_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthApproleRoleRoleNameTokenTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthApproleRoleRoleNameTokenTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_config_certificate_cert_name(configuration: &configuration::Configuration, cert_name: &str) -> Result<(), Error<DeleteAuthAwsConfigCertificateCertNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/certificate/{cert_name}", configuration.base_path, cert_name=crate::apis::urlencode(cert_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsConfigCertificateCertNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_config_client(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteAuthAwsConfigClientError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/client", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsConfigClientError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_config_sts_account_id(configuration: &configuration::Configuration, account_id: &str) -> Result<(), Error<DeleteAuthAwsConfigStsAccountIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/sts/{account_id}", configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsConfigStsAccountIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_config_tidy_identity_whitelist(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteAuthAwsConfigTidyIdentityWhitelistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/identity-whitelist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsConfigTidyIdentityWhitelistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_config_tidy_roletag_blacklist(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteAuthAwsConfigTidyRoletagBlacklistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/roletag-blacklist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsConfigTidyRoletagBlacklistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_identity_whitelist_instance_id(configuration: &configuration::Configuration, instance_id: &str) -> Result<(), Error<DeleteAuthAwsIdentityWhitelistInstanceIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/identity-whitelist/{instance_id}", configuration.base_path, instance_id=crate::apis::urlencode(instance_id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsIdentityWhitelistInstanceIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_role_role(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<DeleteAuthAwsRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_aws_roletag_blacklist_role_tag(configuration: &configuration::Configuration, role_tag: &str) -> Result<(), Error<DeleteAuthAwsRoletagBlacklistRoleTagError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/roletag-blacklist/{role_tag}", configuration.base_path, role_tag=crate::apis::urlencode(role_tag));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAwsRoletagBlacklistRoleTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_azure_config(configuration: &configuration::Configuration, ) -> Result<(), Error<DeleteAuthAzureConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAzureConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_azure_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthAzureRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthAzureRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_cert_certs_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthCertCertsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/certs/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthCertCertsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_cert_crls_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthCertCrlsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/crls/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthCertCrlsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_gcp_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthGcpRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthGcpRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_github_map_teams_key(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<DeleteAuthGithubMapTeamsKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/teams/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthGithubMapTeamsKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_github_map_users_key(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<DeleteAuthGithubMapUsersKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/users/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthGithubMapUsersKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_jwt_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthJwtRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthJwtRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_kubernetes_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthKubernetesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthKubernetesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_ldap_groups_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthLdapGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthLdapGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_ldap_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthLdapUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthLdapUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_oidc_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthOidcRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthOidcRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_okta_groups_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthOktaGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthOktaGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_okta_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthOktaUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthOktaUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_radius_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<DeleteAuthRadiusUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthRadiusUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_token_roles_role_name(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<DeleteAuthTokenRolesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/roles/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthTokenRolesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_auth_userpass_users_username(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<DeleteAuthUserpassUsersUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAuthUserpassUsersUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_alicloud_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAlicloudRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAlicloudRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_alicloud_role_role(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<GetAuthAlicloudRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAlicloudRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_alicloud_roles(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAlicloudRolesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/roles", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAlicloudRolesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthApproleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_bind_secret_id(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameBindSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bind-secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameBindSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_bound_cidr_list(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameBoundCidrListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bound-cidr-list", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameBoundCidrListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_local_secret_ids(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameLocalSecretIdsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/local-secret-ids", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameLocalSecretIdsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_period(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNamePeriodError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/period", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNamePeriodError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_policies(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNamePoliciesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/policies", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNamePoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_role_id(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameRoleIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/role-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameRoleIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_secret_id(configuration: &configuration::Configuration, role_name: &str, list: Option<&str>) -> Result<(), Error<GetAuthApproleRoleRoleNameSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_secret_id_bound_cidrs(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameSecretIdBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameSecretIdBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_secret_id_num_uses(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameSecretIdNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameSecretIdNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_secret_id_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameSecretIdTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameSecretIdTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_token_bound_cidrs(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameTokenBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameTokenBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_token_max_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameTokenMaxTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-max-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameTokenMaxTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_token_num_uses(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameTokenNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameTokenNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_approle_role_role_name_token_ttl(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthApproleRoleRoleNameTokenTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthApproleRoleRoleNameTokenTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_certificate_cert_name(configuration: &configuration::Configuration, cert_name: &str) -> Result<(), Error<GetAuthAwsConfigCertificateCertNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/certificate/{cert_name}", configuration.base_path, cert_name=crate::apis::urlencode(cert_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigCertificateCertNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_certificates(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsConfigCertificatesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/certificates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigCertificatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_client(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthAwsConfigClientError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/client", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigClientError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_identity(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthAwsConfigIdentityError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/identity", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigIdentityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_sts(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsConfigStsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/sts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigStsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_sts_account_id(configuration: &configuration::Configuration, account_id: &str) -> Result<(), Error<GetAuthAwsConfigStsAccountIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/sts/{account_id}", configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigStsAccountIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_tidy_identity_whitelist(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthAwsConfigTidyIdentityWhitelistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/identity-whitelist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigTidyIdentityWhitelistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_config_tidy_roletag_blacklist(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthAwsConfigTidyRoletagBlacklistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/roletag-blacklist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsConfigTidyRoletagBlacklistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_identity_whitelist(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsIdentityWhitelistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/identity-whitelist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsIdentityWhitelistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_identity_whitelist_instance_id(configuration: &configuration::Configuration, instance_id: &str) -> Result<(), Error<GetAuthAwsIdentityWhitelistInstanceIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/identity-whitelist/{instance_id}", configuration.base_path, instance_id=crate::apis::urlencode(instance_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsIdentityWhitelistInstanceIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_role_role(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<GetAuthAwsRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_roles(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsRolesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/roles", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsRolesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_roletag_blacklist(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAwsRoletagBlacklistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/roletag-blacklist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsRoletagBlacklistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_aws_roletag_blacklist_role_tag(configuration: &configuration::Configuration, role_tag: &str) -> Result<(), Error<GetAuthAwsRoletagBlacklistRoleTagError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/roletag-blacklist/{role_tag}", configuration.base_path, role_tag=crate::apis::urlencode(role_tag));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAwsRoletagBlacklistRoleTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_azure_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthAzureConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAzureConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_azure_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthAzureRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAzureRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_azure_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthAzureRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthAzureRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_cert_certs(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthCertCertsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/certs", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthCertCertsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_cert_certs_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthCertCertsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/certs/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthCertCertsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_cert_crls_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthCertCrlsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/crls/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthCertCrlsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_gcp_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthGcpConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGcpConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_gcp_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthGcpRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGcpRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_gcp_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthGcpRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGcpRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_gcp_roles(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthGcpRolesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/roles", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGcpRolesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthGithubConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_duo_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthGithubDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_map_teams(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthGithubMapTeamsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/teams", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubMapTeamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_map_teams_key(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<GetAuthGithubMapTeamsKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/teams/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubMapTeamsKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_map_users(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthGithubMapUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubMapUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_map_users_key(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<GetAuthGithubMapUsersKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/users/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubMapUsersKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_github_mfa_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthGithubMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthGithubMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_jwt_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthJwtConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthJwtConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_jwt_oidc_callback(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthJwtOidcCallbackError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/oidc/callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthJwtOidcCallbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The list will contain the names of the roles.
pub async fn get_auth_jwt_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthJwtRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthJwtRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_jwt_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthJwtRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthJwtRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_kubernetes_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthKubernetesConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthKubernetesConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_kubernetes_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthKubernetesRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthKubernetesRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_kubernetes_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthKubernetesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthKubernetesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthLdapConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_duo_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthLdapDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_groups(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthLdapGroupsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/groups", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_groups_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthLdapGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_mfa_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthLdapMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_users(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthLdapUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_ldap_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthLdapUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthLdapUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_oidc_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthOidcConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOidcConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_oidc_oidc_callback(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthOidcOidcCallbackError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/oidc/callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOidcOidcCallbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The list will contain the names of the roles.
pub async fn get_auth_oidc_role(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthOidcRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/role", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOidcRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_oidc_role_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthOidcRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOidcRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthOktaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_duo_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthOktaDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_groups(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthOktaGroupsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/groups", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_groups_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthOktaGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_mfa_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthOktaMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_users(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthOktaUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_okta_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthOktaUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthOktaUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_radius_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthRadiusConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthRadiusConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_radius_duo_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthRadiusDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthRadiusDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_radius_mfa_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthRadiusMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthRadiusMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_radius_users(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthRadiusUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthRadiusUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_radius_users_name(configuration: &configuration::Configuration, name: &str) -> Result<(), Error<GetAuthRadiusUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthRadiusUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_token_accessors(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthTokenAccessorsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/accessors/", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthTokenAccessorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_token_lookup(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthTokenLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/lookup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthTokenLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_token_lookup_self(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthTokenLookupSelfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/lookup-self", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthTokenLookupSelfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_token_roles(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthTokenRolesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/roles", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthTokenRolesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_token_roles_role_name(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<GetAuthTokenRolesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/roles/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthTokenRolesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_userpass_duo_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthUserpassDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthUserpassDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_userpass_mfa_config(configuration: &configuration::Configuration, ) -> Result<(), Error<GetAuthUserpassMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthUserpassMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_userpass_users(configuration: &configuration::Configuration, list: Option<&str>) -> Result<(), Error<GetAuthUserpassUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = list {
        local_var_req_builder = local_var_req_builder.query(&[("list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthUserpassUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_auth_userpass_users_username(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<GetAuthUserpassUsersUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAuthUserpassUsersUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_alicloud_login(configuration: &configuration::Configuration, inline_object8: Option<crate::models::InlineObject8>) -> Result<(), Error<PostAuthAlicloudLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object8);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAlicloudLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_alicloud_role_role(configuration: &configuration::Configuration, role: &str, inline_object9: Option<crate::models::InlineObject9>) -> Result<(), Error<PostAuthAlicloudRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/alicloud/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object9);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAlicloudRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_login(configuration: &configuration::Configuration, inline_object10: Option<crate::models::InlineObject10>) -> Result<(), Error<PostAuthApproleLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object10);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name(configuration: &configuration::Configuration, role_name: &str, inline_object11: Option<crate::models::InlineObject11>) -> Result<(), Error<PostAuthApproleRoleRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object11);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_bind_secret_id(configuration: &configuration::Configuration, role_name: &str, inline_object12: Option<crate::models::InlineObject12>) -> Result<(), Error<PostAuthApproleRoleRoleNameBindSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bind-secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object12);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameBindSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_bound_cidr_list(configuration: &configuration::Configuration, role_name: &str, inline_object13: Option<crate::models::InlineObject13>) -> Result<(), Error<PostAuthApproleRoleRoleNameBoundCidrListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/bound-cidr-list", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object13);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameBoundCidrListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_custom_secret_id(configuration: &configuration::Configuration, role_name: &str, inline_object14: Option<crate::models::InlineObject14>) -> Result<(), Error<PostAuthApproleRoleRoleNameCustomSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/custom-secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object14);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameCustomSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_period(configuration: &configuration::Configuration, role_name: &str, inline_object15: Option<crate::models::InlineObject15>) -> Result<(), Error<PostAuthApproleRoleRoleNamePeriodError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/period", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object15);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNamePeriodError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_policies(configuration: &configuration::Configuration, role_name: &str, inline_object16: Option<crate::models::InlineObject16>) -> Result<(), Error<PostAuthApproleRoleRoleNamePoliciesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/policies", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object16);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNamePoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_role_id(configuration: &configuration::Configuration, role_name: &str, inline_object17: Option<crate::models::InlineObject17>) -> Result<(), Error<PostAuthApproleRoleRoleNameRoleIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/role-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object17);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameRoleIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id(configuration: &configuration::Configuration, role_name: &str, inline_object18: Option<crate::models::InlineObject18>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object18);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_accessor_destroy(configuration: &configuration::Configuration, role_name: &str, inline_object19: Option<crate::models::InlineObject19>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdAccessorDestroyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-accessor/destroy", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object19);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdAccessorDestroyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_accessor_lookup(configuration: &configuration::Configuration, role_name: &str, inline_object20: Option<crate::models::InlineObject20>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdAccessorLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-accessor/lookup", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object20);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdAccessorLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_bound_cidrs(configuration: &configuration::Configuration, role_name: &str, inline_object21: Option<crate::models::InlineObject21>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object21);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_destroy(configuration: &configuration::Configuration, role_name: &str, inline_object24: Option<crate::models::InlineObject24>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdDestroyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id/destroy", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object24);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdDestroyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_lookup(configuration: &configuration::Configuration, role_name: &str, inline_object25: Option<crate::models::InlineObject25>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id/lookup", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object25);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_num_uses(configuration: &configuration::Configuration, role_name: &str, inline_object22: Option<crate::models::InlineObject22>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object22);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_secret_id_ttl(configuration: &configuration::Configuration, role_name: &str, inline_object23: Option<crate::models::InlineObject23>) -> Result<(), Error<PostAuthApproleRoleRoleNameSecretIdTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/secret-id-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object23);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameSecretIdTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_token_bound_cidrs(configuration: &configuration::Configuration, role_name: &str, inline_object26: Option<crate::models::InlineObject26>) -> Result<(), Error<PostAuthApproleRoleRoleNameTokenBoundCidrsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-bound-cidrs", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object26);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameTokenBoundCidrsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_token_max_ttl(configuration: &configuration::Configuration, role_name: &str, inline_object27: Option<crate::models::InlineObject27>) -> Result<(), Error<PostAuthApproleRoleRoleNameTokenMaxTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-max-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object27);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameTokenMaxTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_token_num_uses(configuration: &configuration::Configuration, role_name: &str, inline_object28: Option<crate::models::InlineObject28>) -> Result<(), Error<PostAuthApproleRoleRoleNameTokenNumUsesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-num-uses", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object28);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameTokenNumUsesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_role_role_name_token_ttl(configuration: &configuration::Configuration, role_name: &str, inline_object29: Option<crate::models::InlineObject29>) -> Result<(), Error<PostAuthApproleRoleRoleNameTokenTtlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/role/{role_name}/token-ttl", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object29);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleRoleRoleNameTokenTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_approle_tidy_secret_id(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthApproleTidySecretIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/approle/tidy/secret-id", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthApproleTidySecretIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_certificate_cert_name(configuration: &configuration::Configuration, cert_name: &str, inline_object30: Option<crate::models::InlineObject30>) -> Result<(), Error<PostAuthAwsConfigCertificateCertNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/certificate/{cert_name}", configuration.base_path, cert_name=crate::apis::urlencode(cert_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object30);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigCertificateCertNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_client(configuration: &configuration::Configuration, inline_object31: Option<crate::models::InlineObject31>) -> Result<(), Error<PostAuthAwsConfigClientError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/client", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object31);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigClientError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_identity(configuration: &configuration::Configuration, inline_object32: Option<crate::models::InlineObject32>) -> Result<(), Error<PostAuthAwsConfigIdentityError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/identity", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object32);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigIdentityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_rotate_root(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthAwsConfigRotateRootError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/rotate-root", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigRotateRootError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_sts_account_id(configuration: &configuration::Configuration, account_id: &str, inline_object33: Option<crate::models::InlineObject33>) -> Result<(), Error<PostAuthAwsConfigStsAccountIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/sts/{account_id}", configuration.base_path, account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object33);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigStsAccountIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_tidy_identity_whitelist(configuration: &configuration::Configuration, inline_object34: Option<crate::models::InlineObject34>) -> Result<(), Error<PostAuthAwsConfigTidyIdentityWhitelistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/identity-whitelist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object34);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigTidyIdentityWhitelistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_config_tidy_roletag_blacklist(configuration: &configuration::Configuration, inline_object35: Option<crate::models::InlineObject35>) -> Result<(), Error<PostAuthAwsConfigTidyRoletagBlacklistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/config/tidy/roletag-blacklist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object35);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsConfigTidyRoletagBlacklistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_login(configuration: &configuration::Configuration, inline_object36: Option<crate::models::InlineObject36>) -> Result<(), Error<PostAuthAwsLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object36);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_role_role(configuration: &configuration::Configuration, role: &str, inline_object37: Option<crate::models::InlineObject37>) -> Result<(), Error<PostAuthAwsRoleRoleError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/role/{role}", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object37);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsRoleRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_role_role_tag(configuration: &configuration::Configuration, role: &str, inline_object38: Option<crate::models::InlineObject38>) -> Result<(), Error<PostAuthAwsRoleRoleTagError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/role/{role}/tag", configuration.base_path, role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object38);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsRoleRoleTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_roletag_blacklist_role_tag(configuration: &configuration::Configuration, role_tag: &str) -> Result<(), Error<PostAuthAwsRoletagBlacklistRoleTagError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/roletag-blacklist/{role_tag}", configuration.base_path, role_tag=crate::apis::urlencode(role_tag));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsRoletagBlacklistRoleTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_tidy_identity_whitelist(configuration: &configuration::Configuration, inline_object39: Option<crate::models::InlineObject39>) -> Result<(), Error<PostAuthAwsTidyIdentityWhitelistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/tidy/identity-whitelist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object39);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsTidyIdentityWhitelistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_aws_tidy_roletag_blacklist(configuration: &configuration::Configuration, inline_object40: Option<crate::models::InlineObject40>) -> Result<(), Error<PostAuthAwsTidyRoletagBlacklistError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/aws/tidy/roletag-blacklist", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object40);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAwsTidyRoletagBlacklistError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_azure_config(configuration: &configuration::Configuration, inline_object41: Option<crate::models::InlineObject41>) -> Result<(), Error<PostAuthAzureConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object41);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAzureConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_azure_login(configuration: &configuration::Configuration, inline_object42: Option<crate::models::InlineObject42>) -> Result<(), Error<PostAuthAzureLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object42);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAzureLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_azure_role_name(configuration: &configuration::Configuration, name: &str, inline_object43: Option<crate::models::InlineObject43>) -> Result<(), Error<PostAuthAzureRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/azure/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object43);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthAzureRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_cert_certs_name(configuration: &configuration::Configuration, name: &str, inline_object44: Option<crate::models::InlineObject44>) -> Result<(), Error<PostAuthCertCertsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/certs/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object44);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthCertCertsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_cert_config(configuration: &configuration::Configuration, inline_object45: Option<crate::models::InlineObject45>) -> Result<(), Error<PostAuthCertConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object45);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthCertConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_cert_crls_name(configuration: &configuration::Configuration, name: &str, inline_object46: Option<crate::models::InlineObject46>) -> Result<(), Error<PostAuthCertCrlsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/crls/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object46);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthCertCrlsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_cert_login(configuration: &configuration::Configuration, inline_object47: Option<crate::models::InlineObject47>) -> Result<(), Error<PostAuthCertLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/cert/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object47);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthCertLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_gcp_config(configuration: &configuration::Configuration, inline_object48: Option<crate::models::InlineObject48>) -> Result<(), Error<PostAuthGcpConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object48);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGcpConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_gcp_login(configuration: &configuration::Configuration, inline_object49: Option<crate::models::InlineObject49>) -> Result<(), Error<PostAuthGcpLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object49);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGcpLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_gcp_role_name(configuration: &configuration::Configuration, name: &str, inline_object50: Option<crate::models::InlineObject50>) -> Result<(), Error<PostAuthGcpRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object50);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGcpRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_gcp_role_name_labels(configuration: &configuration::Configuration, name: &str, inline_object51: Option<crate::models::InlineObject51>) -> Result<(), Error<PostAuthGcpRoleNameLabelsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role/{name}/labels", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object51);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGcpRoleNameLabelsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_gcp_role_name_service_accounts(configuration: &configuration::Configuration, name: &str, inline_object52: Option<crate::models::InlineObject52>) -> Result<(), Error<PostAuthGcpRoleNameServiceAccountsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/gcp/role/{name}/service-accounts", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object52);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGcpRoleNameServiceAccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_config(configuration: &configuration::Configuration, inline_object53: Option<crate::models::InlineObject53>) -> Result<(), Error<PostAuthGithubConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object53);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_duo_access(configuration: &configuration::Configuration, inline_object54: Option<crate::models::InlineObject54>) -> Result<(), Error<PostAuthGithubDuoAccessError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/duo/access", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object54);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubDuoAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_duo_config(configuration: &configuration::Configuration, inline_object55: Option<crate::models::InlineObject55>) -> Result<(), Error<PostAuthGithubDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object55);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_login(configuration: &configuration::Configuration, inline_object56: Option<crate::models::InlineObject56>) -> Result<(), Error<PostAuthGithubLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object56);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_map_teams_key(configuration: &configuration::Configuration, key: &str, inline_object57: Option<crate::models::InlineObject57>) -> Result<(), Error<PostAuthGithubMapTeamsKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/teams/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object57);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubMapTeamsKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_map_users_key(configuration: &configuration::Configuration, key: &str, inline_object58: Option<crate::models::InlineObject58>) -> Result<(), Error<PostAuthGithubMapUsersKeyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/map/users/{key}", configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object58);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubMapUsersKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_github_mfa_config(configuration: &configuration::Configuration, inline_object59: Option<crate::models::InlineObject59>) -> Result<(), Error<PostAuthGithubMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/github/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object59);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthGithubMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
pub async fn post_auth_jwt_config(configuration: &configuration::Configuration, inline_object60: Option<crate::models::InlineObject60>) -> Result<(), Error<PostAuthJwtConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object60);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthJwtConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_jwt_login(configuration: &configuration::Configuration, inline_object61: Option<crate::models::InlineObject61>) -> Result<(), Error<PostAuthJwtLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object61);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthJwtLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_jwt_oidc_auth_url(configuration: &configuration::Configuration, inline_object62: Option<crate::models::InlineObject62>) -> Result<(), Error<PostAuthJwtOidcAuthUrlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/oidc/auth_url", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object62);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthJwtOidcAuthUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_jwt_oidc_callback(configuration: &configuration::Configuration, inline_object63: Option<crate::models::InlineObject63>) -> Result<(), Error<PostAuthJwtOidcCallbackError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/oidc/callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object63);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthJwtOidcCallbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
pub async fn post_auth_jwt_role_name(configuration: &configuration::Configuration, name: &str, inline_object64: Option<crate::models::InlineObject64>) -> Result<(), Error<PostAuthJwtRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/jwt/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object64);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthJwtRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_kubernetes_config(configuration: &configuration::Configuration, inline_object65: Option<crate::models::InlineObject65>) -> Result<(), Error<PostAuthKubernetesConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object65);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthKubernetesConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_kubernetes_login(configuration: &configuration::Configuration, inline_object66: Option<crate::models::InlineObject66>) -> Result<(), Error<PostAuthKubernetesLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object66);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthKubernetesLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_kubernetes_role_name(configuration: &configuration::Configuration, name: &str, inline_object67: Option<crate::models::InlineObject67>) -> Result<(), Error<PostAuthKubernetesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/kubernetes/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object67);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthKubernetesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_config(configuration: &configuration::Configuration, inline_object68: Option<crate::models::InlineObject68>) -> Result<(), Error<PostAuthLdapConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object68);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_duo_access(configuration: &configuration::Configuration, inline_object69: Option<crate::models::InlineObject69>) -> Result<(), Error<PostAuthLdapDuoAccessError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/duo/access", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object69);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapDuoAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_duo_config(configuration: &configuration::Configuration, inline_object70: Option<crate::models::InlineObject70>) -> Result<(), Error<PostAuthLdapDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object70);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_groups_name(configuration: &configuration::Configuration, name: &str, inline_object71: Option<crate::models::InlineObject71>) -> Result<(), Error<PostAuthLdapGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object71);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_login_username(configuration: &configuration::Configuration, username: &str, inline_object72: Option<crate::models::InlineObject72>) -> Result<(), Error<PostAuthLdapLoginUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/login/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object72);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapLoginUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_mfa_config(configuration: &configuration::Configuration, inline_object73: Option<crate::models::InlineObject73>) -> Result<(), Error<PostAuthLdapMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object73);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_ldap_users_name(configuration: &configuration::Configuration, name: &str, inline_object74: Option<crate::models::InlineObject74>) -> Result<(), Error<PostAuthLdapUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/ldap/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object74);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthLdapUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
pub async fn post_auth_oidc_config(configuration: &configuration::Configuration, inline_object75: Option<crate::models::InlineObject75>) -> Result<(), Error<PostAuthOidcConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object75);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOidcConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_oidc_login(configuration: &configuration::Configuration, inline_object76: Option<crate::models::InlineObject76>) -> Result<(), Error<PostAuthOidcLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object76);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOidcLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_oidc_oidc_auth_url(configuration: &configuration::Configuration, inline_object77: Option<crate::models::InlineObject77>) -> Result<(), Error<PostAuthOidcOidcAuthUrlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/oidc/auth_url", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object77);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOidcOidcAuthUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_oidc_oidc_callback(configuration: &configuration::Configuration, inline_object78: Option<crate::models::InlineObject78>) -> Result<(), Error<PostAuthOidcOidcCallbackError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/oidc/callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object78);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOidcOidcCallbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
pub async fn post_auth_oidc_role_name(configuration: &configuration::Configuration, name: &str, inline_object79: Option<crate::models::InlineObject79>) -> Result<(), Error<PostAuthOidcRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/oidc/role/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object79);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOidcRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_config(configuration: &configuration::Configuration, inline_object80: Option<crate::models::InlineObject80>) -> Result<(), Error<PostAuthOktaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object80);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_duo_access(configuration: &configuration::Configuration, inline_object81: Option<crate::models::InlineObject81>) -> Result<(), Error<PostAuthOktaDuoAccessError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/duo/access", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object81);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaDuoAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_duo_config(configuration: &configuration::Configuration, inline_object82: Option<crate::models::InlineObject82>) -> Result<(), Error<PostAuthOktaDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object82);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_groups_name(configuration: &configuration::Configuration, name: &str, inline_object83: Option<crate::models::InlineObject83>) -> Result<(), Error<PostAuthOktaGroupsNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/groups/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object83);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaGroupsNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_login_username(configuration: &configuration::Configuration, username: &str, inline_object84: Option<crate::models::InlineObject84>) -> Result<(), Error<PostAuthOktaLoginUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/login/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object84);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaLoginUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_mfa_config(configuration: &configuration::Configuration, inline_object85: Option<crate::models::InlineObject85>) -> Result<(), Error<PostAuthOktaMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object85);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_okta_users_name(configuration: &configuration::Configuration, name: &str, inline_object86: Option<crate::models::InlineObject86>) -> Result<(), Error<PostAuthOktaUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/okta/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object86);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthOktaUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_config(configuration: &configuration::Configuration, inline_object87: Option<crate::models::InlineObject87>) -> Result<(), Error<PostAuthRadiusConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object87);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_duo_access(configuration: &configuration::Configuration, inline_object88: Option<crate::models::InlineObject88>) -> Result<(), Error<PostAuthRadiusDuoAccessError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/duo/access", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object88);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusDuoAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_duo_config(configuration: &configuration::Configuration, inline_object89: Option<crate::models::InlineObject89>) -> Result<(), Error<PostAuthRadiusDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object89);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_login(configuration: &configuration::Configuration, inline_object90: Option<crate::models::InlineObject90>) -> Result<(), Error<PostAuthRadiusLoginError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/login", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object90);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_login_urlusername(configuration: &configuration::Configuration, urlusername: &str, inline_object91: Option<crate::models::InlineObject91>) -> Result<(), Error<PostAuthRadiusLoginUrlusernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/login/{urlusername}", configuration.base_path, urlusername=crate::apis::urlencode(urlusername));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object91);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusLoginUrlusernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_mfa_config(configuration: &configuration::Configuration, inline_object92: Option<crate::models::InlineObject92>) -> Result<(), Error<PostAuthRadiusMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object92);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_radius_users_name(configuration: &configuration::Configuration, name: &str, inline_object93: Option<crate::models::InlineObject93>) -> Result<(), Error<PostAuthRadiusUsersNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/radius/users/{name}", configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object93);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthRadiusUsersNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_create(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthTokenCreateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_create_orphan(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthTokenCreateOrphanError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/create-orphan", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenCreateOrphanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_create_role_name(configuration: &configuration::Configuration, role_name: &str) -> Result<(), Error<PostAuthTokenCreateRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/create/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenCreateRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_lookup(configuration: &configuration::Configuration, inline_object94: Option<crate::models::InlineObject94>) -> Result<(), Error<PostAuthTokenLookupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/lookup", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object94);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenLookupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_lookup_accessor(configuration: &configuration::Configuration, inline_object95: Option<crate::models::InlineObject95>) -> Result<(), Error<PostAuthTokenLookupAccessorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/lookup-accessor", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object95);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenLookupAccessorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_lookup_self(configuration: &configuration::Configuration, inline_object96: Option<crate::models::InlineObject96>) -> Result<(), Error<PostAuthTokenLookupSelfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/lookup-self", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object96);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenLookupSelfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_renew(configuration: &configuration::Configuration, inline_object97: Option<crate::models::InlineObject97>) -> Result<(), Error<PostAuthTokenRenewError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/renew", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object97);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRenewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_renew_accessor(configuration: &configuration::Configuration, inline_object98: Option<crate::models::InlineObject98>) -> Result<(), Error<PostAuthTokenRenewAccessorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/renew-accessor", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object98);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRenewAccessorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_renew_self(configuration: &configuration::Configuration, inline_object99: Option<crate::models::InlineObject99>) -> Result<(), Error<PostAuthTokenRenewSelfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/renew-self", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object99);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRenewSelfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_revoke(configuration: &configuration::Configuration, inline_object100: Option<crate::models::InlineObject100>) -> Result<(), Error<PostAuthTokenRevokeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/revoke", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object100);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRevokeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_revoke_accessor(configuration: &configuration::Configuration, inline_object101: Option<crate::models::InlineObject101>) -> Result<(), Error<PostAuthTokenRevokeAccessorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/revoke-accessor", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object101);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRevokeAccessorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_revoke_orphan(configuration: &configuration::Configuration, inline_object102: Option<crate::models::InlineObject102>) -> Result<(), Error<PostAuthTokenRevokeOrphanError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/revoke-orphan", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object102);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRevokeOrphanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_revoke_self(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthTokenRevokeSelfError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/revoke-self", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRevokeSelfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_roles_role_name(configuration: &configuration::Configuration, role_name: &str, inline_object103: Option<crate::models::InlineObject103>) -> Result<(), Error<PostAuthTokenRolesRoleNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/roles/{role_name}", configuration.base_path, role_name=crate::apis::urlencode(role_name));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object103);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenRolesRoleNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_token_tidy(configuration: &configuration::Configuration, ) -> Result<(), Error<PostAuthTokenTidyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/token/tidy", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthTokenTidyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_duo_access(configuration: &configuration::Configuration, inline_object104: Option<crate::models::InlineObject104>) -> Result<(), Error<PostAuthUserpassDuoAccessError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/duo/access", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object104);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassDuoAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_duo_config(configuration: &configuration::Configuration, inline_object105: Option<crate::models::InlineObject105>) -> Result<(), Error<PostAuthUserpassDuoConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/duo/config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object105);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassDuoConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_login_username(configuration: &configuration::Configuration, username: &str, inline_object106: Option<crate::models::InlineObject106>) -> Result<(), Error<PostAuthUserpassLoginUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/login/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object106);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassLoginUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_mfa_config(configuration: &configuration::Configuration, inline_object107: Option<crate::models::InlineObject107>) -> Result<(), Error<PostAuthUserpassMfaConfigError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/mfa_config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object107);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassMfaConfigError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_users_username(configuration: &configuration::Configuration, username: &str, inline_object108: Option<crate::models::InlineObject108>) -> Result<(), Error<PostAuthUserpassUsersUsernameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users/{username}", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object108);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassUsersUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_users_username_password(configuration: &configuration::Configuration, username: &str, inline_object109: Option<crate::models::InlineObject109>) -> Result<(), Error<PostAuthUserpassUsersUsernamePasswordError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users/{username}/password", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object109);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassUsersUsernamePasswordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_auth_userpass_users_username_policies(configuration: &configuration::Configuration, username: &str, inline_object110: Option<crate::models::InlineObject110>) -> Result<(), Error<PostAuthUserpassUsersUsernamePoliciesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/auth/userpass/users/{username}/policies", configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object110);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAuthUserpassUsersUsernamePoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

